// Class: ReadRuleFit
// Automatically generated by MethodBase::MakeClass
//

/* configuration options =====================================================

#GEN -*-*-*-*-*-*-*-*-*-*-*- general info -*-*-*-*-*-*-*-*-*-*-*-

Method         : RuleFit::RuleFit
TMVA Release   : 4.2.0         [262656]
ROOT Release   : 5.34/25       [336409]
Creator        : swaban
Date           : Wed Apr 12 00:46:52 2017
Host           : Darwin macitois14.cern.ch 14.0.0 Darwin Kernel Version 14.0.0: Fri Sep 19 00:26:44 PDT 2014; root:xnu-2782.1.97~2/RELEASE_X86_64 x86_64
Dir            : /Users/swaban/Documents/Lectures/Phys-650-75-4172_Spring2017/Lectures/TMVA-v4.2.0/test
Training events: 6000
Analysis type  : [Classification]


#OPT -*-*-*-*-*-*-*-*-*-*-*-*- options -*-*-*-*-*-*-*-*-*-*-*-*-

# Set by User:
V: "False" [Verbose output (short form of "VerbosityLevel" below - overrides the latter one)]
H: "True" [Print method-specific help message]
GDTau: "-1.000000e+00" [Gradient-directed (GD) path: default fit cut-off]
GDTauPrec: "1.000000e-02" [GD path: precision of tau]
GDStep: "1.000000e-02" [GD path: step size]
GDNSteps: "10000" [GD path: number of steps]
GDErrScale: "1.020000e+00" [Stop scan when error > scale*errmin]
fEventsMin: "1.000000e-02" [Minimum fraction of events in a splittable node]
fEventsMax: "5.000000e-01" [Maximum fraction of events in a splittable node]
nTrees: "20" [Number of trees in forest.]
RuleMinDist: "1.000000e-03" [Minimum distance between rules]
MinImp: "1.000000e-03" [Minimum rule importance accepted]
Model: "modrulelinear" [Model to be used]
RuleFitModule: "rftmva" [Which RuleFit module to use]
# Default:
VerbosityLevel: "Default" [Verbosity level]
VarTransform: "None" [List of variable transformations performed before training, e.g., "D_Background,P_Signal,G,N_AllClasses" for: "Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed)"]
CreateMVAPdfs: "False" [Create PDFs for classifier outputs (signal and background)]
IgnoreNegWeightsInTraining: "False" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]
LinQuantile: "2.500000e-02" [Quantile of linear terms (removes outliers)]
GDPathEveFrac: "5.000000e-01" [Fraction of events used for the path search]
GDValidEveFrac: "5.000000e-01" [Fraction of events used for the validation]
ForestType: "adaboost" [Method to use for forest generation (AdaBoost or RandomForest)]
RFWorkDir: "./rulefit" [Friedman's RuleFit module (RFF): working dir]
RFNrules: "2000" [RFF: Mximum number of rules]
RFNendnodes: "4" [RFF: Average number of end nodes]
##


#VAR -*-*-*-*-*-*-*-*-*-*-*-* variables *-*-*-*-*-*-*-*-*-*-*-*-

NVar 4
var1+var2                     myvar1                        myvar1                        myvar1                                                          'F'    [-9.86048698425,7.90235996246]
var1-var2                     myvar2                        myvar2                        Expression 2                                                    'F'    [-3.96643972397,4.0258936882]
var3                          var3                          var3                          Variable 3                    units                             'F'    [-5.3562874794,4.64219379425]
var4                          var4                          var4                          Variable 4                    units                             'F'    [-6.9675450325,5.03067922592]
NSpec 2
var1*2                        spec1                         spec1                         Spectator 1                   units                             'F'    [-11.7982387543,9.52782058716]
var1*3                        spec2                         spec2                         Spectator 2                   units                             'F'    [-17.6973571777,14.2917308807]


============================================================================ */

#include <vector>
#include <cmath>
#include <string>
#include <iostream>

#ifndef IClassifierReader__def
#define IClassifierReader__def

class IClassifierReader {

 public:

   // constructor
   IClassifierReader() : fStatusIsClean( true ) {}
   virtual ~IClassifierReader() {}

   // return classifier response
   virtual double GetMvaValue( const std::vector<double>& inputValues ) const = 0;

   // returns classifier status
   bool IsStatusClean() const { return fStatusIsClean; }

 protected:

   bool fStatusIsClean;
};

#endif

class ReadRuleFit : public IClassifierReader {

 public:

   // constructor
   ReadRuleFit( std::vector<std::string>& theInputVars ) 
      : IClassifierReader(),
        fClassName( "ReadRuleFit" ),
        fNvars( 4 ),
        fIsNormalised( false )
   {      
      // the training input variables
      const char* inputVars[] = { "var1+var2", "var1-var2", "var3", "var4" };

      // sanity checks
      if (theInputVars.size() <= 0) {
         std::cout << "Problem in class \"" << fClassName << "\": empty input vector" << std::endl;
         fStatusIsClean = false;
      }

      if (theInputVars.size() != fNvars) {
         std::cout << "Problem in class \"" << fClassName << "\": mismatch in number of input values: "
                   << theInputVars.size() << " != " << fNvars << std::endl;
         fStatusIsClean = false;
      }

      // validate input variables
      for (size_t ivar = 0; ivar < theInputVars.size(); ivar++) {
         if (theInputVars[ivar] != inputVars[ivar]) {
            std::cout << "Problem in class \"" << fClassName << "\": mismatch in input variable names" << std::endl
                      << " for variable [" << ivar << "]: " << theInputVars[ivar].c_str() << " != " << inputVars[ivar] << std::endl;
            fStatusIsClean = false;
         }
      }

      // initialize min and max vectors (for normalisation)
      fVmin[0] = 0;
      fVmax[0] = 0;
      fVmin[1] = 0;
      fVmax[1] = 0;
      fVmin[2] = 0;
      fVmax[2] = 0;
      fVmin[3] = 0;
      fVmax[3] = 0;

      // initialize input variable types
      fType[0] = 'F';
      fType[1] = 'F';
      fType[2] = 'F';
      fType[3] = 'F';

      // initialize constants
      Initialize();

   }

   // destructor
   virtual ~ReadRuleFit() {
      Clear(); // method-specific
   }

   // the classifier response
   // "inputValues" is a vector of input values in the same order as the 
   // variables given to the constructor
   double GetMvaValue( const std::vector<double>& inputValues ) const;

 private:

   // method-specific destructor
   void Clear();

   // common member variables
   const char* fClassName;

   const size_t fNvars;
   size_t GetNvar()           const { return fNvars; }
   char   GetType( int ivar ) const { return fType[ivar]; }

   // normalisation of input variables
   const bool fIsNormalised;
   bool IsNormalised() const { return fIsNormalised; }
   double fVmin[4];
   double fVmax[4];
   double NormVariable( double x, double xmin, double xmax ) const {
      // normalise to output range: [-1, 1]
      return 2*(x - xmin)/(xmax - xmin) - 1.0;
   }

   // type of input variable: 'F' or 'I'
   char   fType[4];

   // initialize internal variables
   void Initialize();
   double GetMvaValue__( const std::vector<double>& inputValues ) const;

   // private members (method specific)
   // not implemented for class: "ReadRuleFit"
};
void   ReadRuleFit::Initialize(){}
void   ReadRuleFit::Clear(){}
double ReadRuleFit::GetMvaValue__( const std::vector<double>& inputValues ) const {
   double rval=1.135179342;
   //
   // here follows all rules ordered in importance (most important first)
   // at the end of each line, the relative importance of the rule is given
   //
   if ((-0.5561385751<inputValues[0])) rval+=-0.3004300618;   // importance = 0.282
   if ((-0.5951059461<inputValues[2])&&(inputValues[3]<0.7859993577)) rval+=-0.2548056951;   // importance = 0.242
   if ((inputValues[3]<-0.6827608943)) rval+=-0.2561974727;   // importance = 0.219
   if ((inputValues[2]<0.8332485557)&&(inputValues[3]<-0.5594935417)) rval+=-0.2475817775;   // importance = 0.218
   if ((0.2155562788<inputValues[0])&&(inputValues[1]<0.6006079316)) rval+=-0.2268373809;   // importance = 0.205
   if ((inputValues[0]<1.135561109)&&(inputValues[3]<-0.03049062565)) rval+=-0.2075473134;   // importance = 0.200
   if ((inputValues[0]<1.135561109)&&(-0.03049062565<inputValues[3])) rval+=0.2146283774;   // importance = 0.191
   if ((-0.09556125104<inputValues[0])&&(inputValues[0]<1.860857725)&&(inputValues[3]<0.8881428242)) rval+=-0.228153635;   // importance = 0.189
   if ((-0.5561385751<inputValues[0])&&(-0.4962730408<inputValues[1])&&(-1.240964532<inputValues[2])) rval+=-0.1835456175;   // importance = 0.175
   if ((inputValues[0]<-0.02694161795)&&(inputValues[2]<-0.06615076959)&&(inputValues[3]<-0.4579730034)) rval+=-0.1980839475;   // importance = 0.173
   if ((-2.247838259<inputValues[0])&&(inputValues[2]<1.104419231)&&(inputValues[3]<0.252938956)) rval+=-0.1760306839;   // importance = 0.169
   if ((inputValues[1]<1.74236989)&&(-1.071224093<inputValues[2])&&(inputValues[3]<1.964361787)) rval+=-0.1899131182;   // importance = 0.165
   if ((-1.302328587<inputValues[1])&&(-1.071224093<inputValues[2])) rval+=-0.1733891591;   // importance = 0.149
   if ((-1.302328587<inputValues[1])) rval+=-0.2220924593;   // importance = 0.140
   if ((inputValues[0]<-0.5561385751)&&(inputValues[1]<0.01028927136)&&(-0.9867633581<inputValues[3])) rval+=0.2512873435;   // importance = 0.140
   if ((-0.5561385751<inputValues[0])&&(-0.4962730408<inputValues[1])) rval+=-0.1459254024;   // importance = 0.139
   if ((-0.5561385751<inputValues[0])&&(1.181050539<inputValues[3])) rval+=0.1686617102;   // importance = 0.133
   if ((-1.790360451<inputValues[0])&&(-0.5411539674<inputValues[1])&&(0.1678158939<inputValues[3])) rval+=0.1432171733;   // importance = 0.131
   if ((-0.09556125104<inputValues[0])&&(inputValues[0]<1.860857725)&&(0.8881428242<inputValues[3])) rval+=0.1888605768;   // importance = 0.130
   if ((inputValues[2]<0.8332485557)) rval+=-0.1548476498;   // importance = 0.122
   if ((inputValues[0]<-0.5561385751)&&(inputValues[1]<-0.00770324748)&&(inputValues[3]<-0.9867633581)) rval+=-0.1985788573;   // importance = 0.113
   if ((inputValues[0]<0.2897112668)&&(-0.06537637115<inputValues[1])) rval+=0.1228727481;   // importance = 0.108
   if ((inputValues[0]<-0.5561385751)&&(-0.00770324748<inputValues[1])&&(inputValues[3]<-0.9867633581)) rval+=-0.1896024023;   // importance = 0.106
   if ((-1.302328587<inputValues[1])&&(inputValues[1]<1.235080123)&&(-1.071224093<inputValues[2])&&(inputValues[2]<0.8336961865)) rval+=0.09495568046;   // importance = 0.092
   if ((inputValues[0]<1.310519457)&&(inputValues[1]<1.74236989)&&(-1.071224093<inputValues[2])&&(0.08754192293<inputValues[3])) rval+=0.1055772154;   // importance = 0.091
   if ((inputValues[2]<0.8332485557)&&(-0.5594935417<inputValues[3])) rval+=0.09340433039;   // importance = 0.090
   if ((inputValues[1]<1.74236989)&&(-1.071224093<inputValues[2])&&(1.451897502<inputValues[3])) rval+=0.1219507272;   // importance = 0.081
   if ((-1.302328587<inputValues[1])&&(inputValues[1]<1.235080123)&&(-1.071224093<inputValues[2])) rval+=0.08419600533;   // importance = 0.079
   if ((inputValues[0]<0.2897112668)&&(inputValues[1]<-0.06537637115)) rval+=0.0848517324;   // importance = 0.074
   if ((-2.247838259<inputValues[0])&&(inputValues[0]<0.8218057156)&&(inputValues[2]<1.104419231)&&(inputValues[3]<0.252938956)) rval+=-0.07623239377;   // importance = 0.073
   if ((1.310519457<inputValues[0])&&(inputValues[1]<1.74236989)&&(-1.071224093<inputValues[2])&&(1.451897502<inputValues[3])) rval+=0.1051809234;   // importance = 0.067
   if ((inputValues[1]<1.74236989)&&(inputValues[2]<-1.071224093)) rval+=-0.09407727596;   // importance = 0.065
   if ((-0.5951059461<inputValues[2])&&(0.7859993577<inputValues[3])) rval+=0.07259827325;   // importance = 0.064
   if ((0.8332485557<inputValues[2])) rval+=-0.0805606332;   // importance = 0.064
   if ((-0.929166615<inputValues[0])&&(inputValues[0]<1.310519457)&&(inputValues[1]<1.74236989)&&(-1.071224093<inputValues[2])&&(0.08754192293<inputValues[3])) rval+=0.07180632055;   // importance = 0.061
   if ((0.01028927136<inputValues[1])&&(-1.254104853<inputValues[3])) rval+=0.05395550785;   // importance = 0.052
   if ((inputValues[1]<-0.5411539674)&&(inputValues[3]<0.2732710838)) rval+=-0.0567032539;   // importance = 0.042
   if ((-1.302328587<inputValues[1])&&(inputValues[1]<1.235080123)&&(-1.071224093<inputValues[2])&&(inputValues[2]<0.8336961865)&&(inputValues[3]<-0.0268173907)) rval+=0.05008344063;   // importance = 0.040
   if ((-1.302328587<inputValues[1])&&(inputValues[1]<1.235080123)&&(-1.071224093<inputValues[2])&&(inputValues[2]<0.8336961865)&&(-0.0268173907<inputValues[3])) rval+=0.04524737706;   // importance = 0.038
   if ((-0.09556125104<inputValues[0])&&(inputValues[0]<1.860857725)) rval+=-0.0392093034;   // importance = 0.037
   if ((inputValues[0]<1.860857725)) rval+=-0.05169947849;   // importance = 0.034
   if ((-1.302328587<inputValues[1])&&(inputValues[2]<-1.071224093)) rval+=-0.04854015471;   // importance = 0.033
   if ((-0.1777818501<inputValues[1])&&(inputValues[3]<-0.1114168838)) rval+=-0.04093551977;   // importance = 0.033
   if ((inputValues[1]<1.74236989)&&(-1.685114622<inputValues[2])&&(inputValues[2]<-1.071224093)) rval+=0.04968301663;   // importance = 0.028
   if ((-1.159725547<inputValues[1])&&(inputValues[1]<-0.5411539674)&&(0.2732710838<inputValues[3])) rval+=-0.05448580345;   // importance = 0.027
   if ((inputValues[1]<1.74236989)&&(-1.071224093<inputValues[2])) rval+=-0.02873215918;   // importance = 0.023
   if ((-0.6827608943<inputValues[3])) rval+=0.02140625365;   // importance = 0.018
   if ((0.2155562788<inputValues[0])&&(-0.4873119295<inputValues[1])&&(inputValues[1]<0.6006079316)) rval+=0.02262145592;   // importance = 0.016
   if ((inputValues[1]<-0.5411539674)&&(0.2732710838<inputValues[3])) rval+=0.01571734085;   // importance = 0.011
   if ((inputValues[1]<-1.302328587)) rval+=-0.01267368602;   // importance = 0.008
   if ((0.8064263463<inputValues[0])&&(-0.5411539674<inputValues[1])&&(inputValues[3]<0.1678158939)) rval+=-0.04291259947;   // importance = 0.007
   if ((-0.5561385751<inputValues[0])&&(-0.4962730408<inputValues[1])&&(inputValues[2]<-1.240964532)) rval+=0.03607017326;   // importance = 0.006
   if ((0.1584071815<inputValues[2])&&(inputValues[2]<0.8332485557)&&(inputValues[3]<-0.5594935417)) rval+=-0.03024532917;   // importance = 0.005
   if ((-2.247838259<inputValues[0])&&(1.104419231<inputValues[2])&&(inputValues[3]<0.252938956)) rval+=-0.04058623907;   // importance = 0.004
   if ((0.8064263463<inputValues[0])&&(-0.5411539674<inputValues[1])&&(inputValues[1]<0.5391710401)&&(inputValues[3]<0.1678158939)) rval+=-0.02499419861;   // importance = 0.003
   if ((inputValues[0]<-0.02694161795)&&(-0.06615076959<inputValues[2])&&(inputValues[3]<-0.4579730034)) rval+=-0.005622227378;   // importance = 0.001
   //
   // here follows all linear terms
   // at the end of each line, the relative importance of the term is given
   //
   rval+=-0.2159904298*std::min( double(3.45971489), std::max( double(inputValues[0]), double(-3.404512405)));   // importance = 0.739
   rval+=-0.1140460485*std::min( double(2.15785718), std::max( double(inputValues[1]), double(-2.181216717)));   // importance = 0.255
   rval+=-0.09799511314*std::min( double(2.025066853), std::max( double(inputValues[2]), double(-2.081344366)));   // importance = 0.209
   rval+=0.3975173423*std::min( double(2.574189901), std::max( double(inputValues[3]), double(-2.336661816)));   // importance = 1.000
   return rval;
}
   inline double ReadRuleFit::GetMvaValue( const std::vector<double>& inputValues ) const
   {
      // classifier response value
      double retval = 0;

      // classifier response, sanity check first
      if (!IsStatusClean()) {
         std::cout << "Problem in class \"" << fClassName << "\": cannot return classifier response"
                   << " because status is dirty" << std::endl;
         retval = 0;
      }
      else {
         if (IsNormalised()) {
            // normalise variables
            std::vector<double> iV;
            iV.reserve(inputValues.size());
            int ivar = 0;
            for (std::vector<double>::const_iterator varIt = inputValues.begin();
                 varIt != inputValues.end(); varIt++, ivar++) {
               iV.push_back(NormVariable( *varIt, fVmin[ivar], fVmax[ivar] ));
            }
            retval = GetMvaValue__( iV );
         }
         else {
            retval = GetMvaValue__( inputValues );
         }
      }

      return retval;
   }
